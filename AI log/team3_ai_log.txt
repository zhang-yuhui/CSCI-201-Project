Team 3 Final Project AI Log
CSCI 201 Fall 2025

CafeFinder
Team Members: Angela Zhuang, Daniel Lee, Hannah Lee, Yuhui Zhang, Manuela Berrio, Tibor Fober, Cindy Zhou, Jiayu Li

Prompt
The project is a full-stack web application with React in the frontend and Spring Boot as the backend. The goal is to create a map with markers/pins representing specific locations. Please create a React component using Leaflet, an open-source JavaScript library for interactive maps, with one marker and one marker popup. 

Issues
Nothing was displaying when navigating to the MapWithMarker page after running the web application, even after implementing the MapWithMarker component and creating a page that App.js routes to.

Fix
There was a mismatched dependency between React, React-Leaflet, and Leaflet. The specific versions of React, React-Leaflet, and Leaflet used for the application had to be React 18, React-Leaflet v4, and Leaflet v1.9.4. The JSON package file was updated to ensure that these specific versions were installed. There were no errors after this.

Explanation
It is important to ensure that each of the frameworks and libraries being used are compatible with one another. When there are mismatched dependencies, as displayed by this specific instance, there will be errors and the code will not function as intended.


Prompt
Based on our Cafe specifications in the documentation, as well as the SQL schema for the Cafes table, please create a SQL schema as well as a Java model class for Cafe. Please also create a Java class which connects to my SQL database, retrieves all cafe rows, and returns a list of the cafes from the database for my backend API.

Issues
The returned Cafe.java Java class and the data.sql SQL schema were great and did not have any errors. However, for the Java class which connects to the database and returns a list of cafes, ChatGPT returned a CafeDAO.java class. However, the issue was that the CafeDAO.java class did not match the existing structure of the code where there are controller, dto, model, repository, and service folders. So, I asked ChatGPT to again create code for the same purpose, but this time following the project directory structure.

Fix
ChatGPT returned the CafeController.java file for the controller folder, which allows for functions such as getting all cafes from the database, and CafeRequest.java for the dto folder, which represents the fields that would be returned when requesting a cafe from the database, Cafe.java in the model folder which is the aforementioned Cafe class, and CafeRepository.java in the repository folder and CafeService.java in the service folder. Now, the structure followed the code structure.

Explanation
This fix was important for code consistency as well as for it to be structured in a way that was easy to understand and edit for our React and Spring Boot tech stack. In the real world, there are standards to adhere when coding, especially when building upon previous code and existing practices that are optimal to follow.


Prompt
Please now integrate the backend with the frontend. The goal is for all of the cafes in the database appear with a marker for the frontend map, and when the user clicks on the marker on the map, information about the specific cafe including the name, address, star rating, description, etc. are displayed.

Issues
After implementing the code given by ChatGPT to do this task, some cafe marker information was not displaying on the frontend whenever a cafe marker was clicked. Also, the cafe marker information was not formatted in the desired format. For instance, for the cafe price, instead of displaying three dollar signs ($$$) if the cafe price was listed as 3 (for pricey), the information simply displayed the number 3.

Fix
The price was fixed so that there was a dollar sign displayed as many times as price was set to in the database. In addition, to fix how the cafe overall rating was not being displayed when the cafe marker was clicked, it turns out that instead of referencing cafe.cafe_id, the reference was supposed to be cafe.cafeId and similarly cafe.overall_rating was to be cafe.overallRating since the backend JSON uses camel case and not snake case.

Explanation
Once again, naming conventions and consistency is important so that errors such as these do not arise. In addition, it is important to display the entirety of the cafe information for the users, since the goal of the project is to help users find cafes to visit based off this provided cafe information. This will help us reach the project goal and make the user experience better.


Prompt

Starter code

create a starter code for a web app with front end ReactJS and backend Spring boot with java 21 and MySQL DB, and I would also like a user authentification library for managing user login and making it easy. Specifically use spring security, maven and create react app. Also, write the appropriate .gitignore.

Main page for testing login

can you create a nav bar to route these paths? Include the dashboard and the login/out button.

Issues

Issues with testing protected endpoint

why I test endpoint http://localhost:8080/api/test/public
 with GET but I still get 403 in @TestController.java

Issues with role vs url based filter

what's the difference of filterChain in @SecurityConfig.java:

.authorizeHttpRequests(auth -> auth
.requestMatchers("/api/auth/**").permitAll()
.requestMatchers("/api/test/public").permitAll()
.anyRequest().authenticated()
)

and in @TestController.java (21):

@PreAuthorize("hasRole('USER')")
public ResponseEntity<String> protectedEndpoint() { ... }

why both are needed, can it be simplified for cleaner code.

Issues with git merge conflict

After someone else updated all at the same file, merge is complicated.

Fix

testing protected endpoint

Updating SecurityConfig.java to allow /api/test/public without authentication:

.requestMatchers("/api/auth/**").permitAll()
.requestMatchers("/api/test/public").permitAll()
.anyRequest().authenticated()

role vs url based filter

Use only role-based authentication because some endpoints such as map or coffee shop are public but others (user profile, user's coffee rating) are protected.
In SecurityConfig.java allow all the request in http filter:

.requestMatchers("/api/auth/**").permitAll()
.requestMatchers("/api/test/public").permitAll()
.anyRequest().authenticated()

Git merge conflict

activate option for merge by default:

cd /Users/zhangyuhui/Downloads/CSCI-201-Project && git config pull.rebase false
cd /Users/zhangyuhui/Downloads/CSCI-201-Project && git pull origin main
cd /Users/zhangyuhui/Downloads/CSCI-201-Project && git add frontend/src/App.js

Explanation

The issue is in SecurityConfig.java: only /api/auth/** is permitted, so /api/test/public requires authentication.

filterChain in SecurityConfig.java
Purpose: HTTP-level authentication (who can access).
Runs before the request reaches the controller.
Determines if an endpoint requires authentication.
URL pattern–based.
Coarse-grained: public vs authenticated.

@PreAuthorize("hasRole('USER')") in TestController.java
Purpose: Method-level authorization (what roles are allowed).
Runs after authentication, before the method executes.
Checks roles/permissions of the authenticated user.
Method-level.
Fine-grained: which roles can access.

After using only role-based authentication:

Request comes in → JWT filter processes it (sets authentication if token is valid)

Request reaches controller → @PreAuthorize annotation checks authorization

If authorized → method executes

If not authorized → 403 Forbidden

For the merge issue: the local branch has a commit (“43cb1bb - Finished login backend and User DB...”) that isn't on the remote, and the remote has two commits (“acd006a” and “34bc1d2” about MapWithMarker) that aren't on your local branch.


Prompt
Add an "Apply" button to the filter panel in the CafeMap component so that users can select multiple filter options (amenities, price range, rating, distance) before applying them all at once. The filters should only update the displayed cafes when the user clicks the Apply button, not immediately as they adjust each filter.

Issues
The original implementation applied filters immediately as users toggled checkboxes or adjusted sliders, which could be jarring and didn't allow users to experiment with different filter combinations before committing to them. This also meant multiple unnecessary re-renders and filter operations as users made adjustments.

Fix
Created a separate tempFilters state to track the user's current selections while they're editing in the filter panel. Added a handleApplyFilters function that copies tempFilters to the actual filters state and closes the panel when the Apply button is clicked. Updated all filter controls (checkboxes, sliders) to modify tempFilters instead of filters directly. Added a useEffect hook to reset tempFilters to match filters whenever the panel opens, ensuring users see their currently active filters.

Explanation
Separating the temporary editing state from the applied filter state provides a better user experience by allowing users to preview and adjust multiple filter options before committing. This pattern is common in filter interfaces and prevents unnecessary computation and UI updates while users are still deciding on their filter criteria. It also gives users the ability to close the panel without applying changes if they decide not to modify the filters.


Prompt
Integrate the CafeMap component with the MySQL database backend to fetch and filter real cafe data instead of using simulated/fake data. The cafes should be fetched from the Spring Boot API endpoint at http://localhost:8080/api/cafes and filtered based on their database fields (tags, price, overallRating) according to the user's selected filter options.

Issues
The CafeMap component was using hardcoded temporary cafe data for testing, and MapWithMarker was independently fetching all cafes from the API. This caused duplicate data fetching and prevented the filter functionality from working with real data. Additionally, the cafe data structure from the database (with comma-separated tags like "wifi,bathrooms,outlets") needed to be properly parsed to check against the filter selections.

Fix
Removed the fake data from CafeMap and added a useEffect hook to fetch real cafe data from http://localhost:8080/api/cafes on component mount. Created two state variables: allCafes to store the complete dataset and filteredCafes to store the filtered results. Updated the filterCafes function to parse the comma-separated tags string from the database and check if it includes the selected amenities. Modified MapWithMarker to accept a cafes prop instead of fetching data itself, eliminating duplicate API calls. This established a proper parent-child data flow where CafeMap fetches and filters the data, then passes only the filtered results to MapWithMarker for display.

Explanation
Separating data fetching from display logic creates a cleaner architecture with a single source of truth. By having the parent component (CafeMap) manage both the raw data and filtering logic, we ensure that the map always displays exactly what matches the current filters. This approach also makes the MapWithMarker component more reusable since it now simply displays whatever cafe data it receives as props, rather than being tightly coupled to a specific API endpoint.

Prompt
Provided ChatGPT with the template code for login page along with descriptions on how to style along with image from Figma. 

Issue 
Requesting help for styling pages to match better, and to fix the layout of the code. 

Fix
Was provided with working code on how to properly format the page, regarding alignment, font, and color choices. 

Explanation
Quickly add css details to the website and quickly reformat code. 